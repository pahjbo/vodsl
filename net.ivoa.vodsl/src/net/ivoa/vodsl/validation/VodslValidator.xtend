/*
 * generated by Xtext
 */
package net.ivoa.vodsl.validation

import net.ivoa.vodsl.vodsl.Attribute
import net.ivoa.vodsl.vodsl.Multiplicity
import net.ivoa.vodsl.vodsl.MultiplicityBound
import net.ivoa.vodsl.vodsl.ValueType
import net.ivoa.vodsl.vodsl.VodslPackage
import org.eclipse.xtext.validation.Check

import static net.ivoa.vodsl.vodsl.MultiplicityBound.*
import net.ivoa.vodsl.vodsl.Reference
import net.ivoa.vodsl.vodsl.ObjectType
import net.ivoa.vodsl.vodsl.DataType
import net.ivoa.vodsl.vodsl.Composition

/**
 * Custom validation rules. 
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#validation
 * 
 * TODO - need to make sure that composition target is only used once - probably better done with direct EMF validation
 * would like to report errors with the fully qualified name
 */
class VodslValidator extends AbstractVodslValidator {

	@Check
	def checkAttributeType(Attribute attr) {
		if (!(attr.type instanceof ValueType)) {

			error("Attribute '" + attr.name + "' should be a value type", VodslPackage.Literals.ATTRIBUTE__TYPE)
		}
	}

	def checkAbstract(DataType t) {
		if (t.abstract)
			if (t.content.empty)
				warning('abstract datatype with no members ', VodslPackage.Literals.DEFINITION_TYPE__ABSTRACT)
	}

// actually  abstract attributes are ok - probably want to check that abstract class h	
//	@Check
//	def checkAttrNotAbstract(Attribute attr) {
//		val p = attr.eContainer
//		val parentAbstract = switch (p)
//		{
//			DataType case p.abstract: true
//			ObjectType case p.abstract : true
//			default: false
//		}
//	
//		if (!attr.composition) {
//			val at = attr.type
//			if ((at instanceof ValueType)) {
//            val attrAbstract = switch (at){
//            	DataType case at.abstract: true
//            	default: false
//            }
//            
//				if (!parentAbstract && attrAbstract) error('Attribute  '+attr.name+' - type is abstract', VodslPackage.Literals.ATTRIBUTE__TYPE)
//			}
//		}
//
//	}

	@Check
	def checkMultiplicity(Multiplicity mul) {
		val typ = mul.eContainer
		switch (typ) {
			Attribute: checkMultiplicity(typ)
			Reference: checkMultiplicity(typ)
			Composition : checkMultiplicity(typ)
		}

	}

	def checkMultiplicity(Reference typ) {
		val mul = typ.multiplicity
		if (mul.multiplicitySpec != null) {
			switch mul.multiplicitySpec {
				case ATLEASTONE: {
					warning("multiplicity '+' not advised for reference "+typ.name+"\n unless pure aggregation\n see VO-DML spec 4.19 ",
						VodslPackage.Literals.MULTIPLICITY__MULTIPLICITY_SPEC)
				}
				case MANY: {
					error("multiplicity '*' not advised for reference"+typ.name+"\n see VO-DML spec 4.19",
						VodslPackage.Literals.MULTIPLICITY__MULTIPLICITY_SPEC)

				}
				case OPTIONAL: {
					// OK
				}
				case ONE: {
					if (mul.maxOccurs != 1 || mul.minOccurs != 1) {
						warning("max occurs > 1 not advised for reference"+typ.name+"\n see VO-DML spec 4.19 " ,
							VodslPackage.Literals.MULTIPLICITY__MAX_OCCURS)
					}
				}
			}
		}

	}

	def checkMultiplicity(Composition typ) {
		val mul = typ.multiplicity

		if (mul.multiplicitySpec == null || mul.multiplicitySpec == MultiplicityBound.ONE) {
			if (mul.maxOccurs < mul.minOccurs) {
				error("maximum multiplicity less than minimum - " + typ.name,
					VodslPackage.Literals.MULTIPLICITY__MAX_OCCURS)
			}
		}
	}

	def checkMultiplicity(Attribute typ) {
		val mul = typ.multiplicity
		if (mul.multiplicitySpec != null) {
			switch mul.multiplicitySpec {
				case ATLEASTONE: {
					error("multiplicity '+' strongly discouraged for attribute " + typ.name,
						VodslPackage.Literals.MULTIPLICITY__MULTIPLICITY_SPEC)
				}
				case MANY: {
					error("multiplicity '*' strongly discouraged for attribute " + typ.name,
						VodslPackage.Literals.MULTIPLICITY__MULTIPLICITY_SPEC)
				}
				case OPTIONAL: {
					// OK
				}
				case ONE: {
					if (mul.maxOccurs != 0 && mul.minOccurs != mul.maxOccurs) {
						error("multiplicity for attribute should specify array size so that min=max for " + typ.name,
							VodslPackage.Literals.MULTIPLICITY__MAX_OCCURS)
					}
				}
			}
		}

	}

}
