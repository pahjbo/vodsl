/**
 * generated by Xtext - then hand edited by Paul Harrison.
 */
package net.ivoa.vodsl.generator


import org.eclipse.emf.ecore.resource.Resource
import net.ivoa.vodsl.vodsl.IncludeDeclaration
import net.ivoa.vodsl.vodsl.PackageDeclaration
import net.ivoa.vodsl.vodsl.ObjectType
import net.ivoa.vodsl.vodsl.Enumeration
import net.ivoa.vodsl.vodsl.DataType
import net.ivoa.vodsl.vodsl.PrimitiveType
import net.ivoa.vodsl.vodsl.VoDataModel
import net.ivoa.vodsl.vodsl.EnumLiteral
import net.ivoa.vodsl.vodsl.Attribute
import net.ivoa.vodsl.vodsl.Constraint
import net.ivoa.vodsl.vodsl.Multiplicity
import net.ivoa.vodsl.vodsl.ReferableElement
import java.util.TimeZone
import java.text.DateFormat
import java.text.SimpleDateFormat
import java.util.Date
import net.ivoa.vodsl.vodsl.Reference
import org.eclipse.xtext.generator.AbstractGenerator
import org.eclipse.xtext.generator.IGeneratorContext
import org.eclipse.xtext.generator.IFileSystemAccess2
import net.ivoa.vodsl.vodsl.Composition
import java.util.List
import com.google.inject.Inject
import org.eclipse.xtext.naming.IQualifiedNameProvider
import org.eclipse.xtext.naming.IQualifiedNameConverter
import net.ivoa.vodsl.vodsl.SubSet
import net.ivoa.vodsl.vodsl.NaturalKey
import net.ivoa.vodsl.vodsl.SemanticConcept
import net.ivoa.vodsl.vodsl.Role
import org.eclipse.xtext.scoping.impl.ImportUriResolver
import org.eclipse.xtext.EcoreUtil2

/**
 * Generates code from your model files on save.
 * 
 * see http://www.eclipse.org/Xtext/documentation.html#TutorialCodeGeneration
 */
class VodslGenerator extends AbstractGenerator  {

    @Inject extension IQualifiedNameProvider	
    @Inject IQualifiedNameConverter converter 
    @Inject ImportUriResolver uriResolver
	
    
	 static val TimeZone tz = TimeZone.getTimeZone("UTC")
    static val DateFormat df = new SimpleDateFormat("yyyy-MM-dd'T'HH:mm:ss'Z'")
    var Date modDate
    
    new()
    {
    	df.setTimeZone(tz)
    }
	
	override void doGenerate(Resource resource, IFileSystemAccess2 fsa, IGeneratorContext context) {
		val vodecl = resource.allContents.filter(typeof(VoDataModel)).head // surely there must be a better way of getting this one....
		val modelDecl = vodecl.model
		val filenameOnly = resource.URI.lastSegment		
		modDate = new Date(resource.timeStamp)
		val filename = filenameOnly.substring(0,filenameOnly.lastIndexOf('.')) +  '.vo-dml.xml'
		fsa.generateFile(filename, vodecl.vodml)
	}
	
	
	def vodml(VoDataModel e){
	'''
<?xml version="1.0" encoding="UTF-8"?>
<vo-dml:model xmlns:vo-dml="http://www.ivoa.net/xml/VODML/v1" 
              xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance"
              xsi:schemaLocation="http://www.ivoa.net/xml/VODML/v1 https://www.ivoa.net/xml/VODML/vo-dml-v1.xsd" 
              vodmlVersion="1.1">	<!-- file generated from VODSL - needs validatation against v1.1 of schema  --> 
      <name>«e.model.name»</name>
      <description>«e.model.description»</description> 
      <uri/>
      <title>«e.model.titular»</title>
      «FOR a:e.model.authors»
        <author>«a»</author>
      «ENDFOR»
      <version>«e.model.version»</version>
      <lastModified>«df.format(modDate)»</lastModified>
      «FOR f:e.includes»
      	«f.vodml»
      «ENDFOR» 
      «e.elements.vodml»
</vo-dml:model>
	'''
	}
	
	def vodml(IncludeDeclaration e) { 
	    val resource = EcoreUtil2.getResource(e.eResource,uriResolver.resolve(e))
	    val vodecl = resource.allContents.filter(typeof(VoDataModel)).head // surely there must be a better way of getting this one....
		val modelDecl = vodecl.model
		
		return '''
	<import>
	  <name>«modelDecl.name»</name>
	  <version>«modelDecl.version»</version>
	  <url>«e.importURI.substring(if (e.importURI.lastIndexOf('/') == -1) 0 else e.importURI.lastIndexOf('/')+1,e.importURI.lastIndexOf('.')) +'.vo-dml.xml'»</url>
	  <documentationURL>not known</documentationURL>
	</import>
	'''
	}
	
	def vodml(ReferableElement e)
	{
      //shame that xtend does not do dynamic dispatch - at least not in the way that I thought....
      switch  e {
      	PackageDeclaration : (e as PackageDeclaration).vodml
      	ObjectType : (e as ObjectType).vodml
      	Enumeration : (e as Enumeration).vodml
      	DataType : (e as DataType).vodml
      	PrimitiveType: (e as PrimitiveType).vodml
      	Attribute: (e as Attribute).vodml
      	default: "unknown type " + e.class
      }
      		
 
	}
	
	def vodml(Role e)
	{
      switch  e {
      	
      	Composition : (e as Composition).vodml
      	Reference : (e as Reference).vodml
      	Attribute: (e as Attribute).vodml
      	default: "unknown type " + e.class
      }
 		
	}
	
	def preamble(ReferableElement e) '''
	   <vodml-id>«e.fullyQualifiedName.skipFirst(1)»</vodml-id>
	   <name>«e.name»</name>
	   <description>«e.description»</description>	    
	'''
	
	
	def vodml(List<ReferableElement> e) '''
	   «FOR f: e.filter(PrimitiveType)»
         «(f as PrimitiveType).vodml»
      «ENDFOR»
      «FOR f: e.filter(Enumeration)»
         «(f as Enumeration).vodml»
      «ENDFOR»
      «FOR f: e.filter(DataType)»
         «(f as DataType).vodml»
      «ENDFOR»
      «FOR f: e.filter(ObjectType)»
         «(f as ObjectType).vodml»
      «ENDFOR»
      «FOR f: e.filter(PackageDeclaration)»
         «(f as PackageDeclaration).vodml»
      «ENDFOR»		
'''	
	
	def vodml (PackageDeclaration e)'''
	<package>
	   «e.preamble»
       «e.elements.vodml»
	</package>
	'''
	def vodml (ObjectType e)'''
	<objectType«IF e.abstract» abstract="true"«ENDIF»>
	   «e.preamble»
	   «IF e.superType !== null»
	   <extends>
	      «(e.superType as ReferableElement).ref»
	   </extends>
	   «ENDIF»
	   «FOR f: e.constraints»
	   	«f.vodml»
	   «ENDFOR»
	   «FOR f: e.subsets»
	   	«f.vodml»
	   «ENDFOR»	   
	   «FOR f: e.content»
	   	«f.vodml»
	   «ENDFOR»
	</objectType>
	'''
	def vodml (Attribute e)'''
	<attribute>
	  «e.preamble»
	  <datatype>
	     «(e.type as ReferableElement).ref»
	  </datatype>
	  «vodml(e.multiplicity)»
	«IF e.semanticConcept !== null»
	  «e.semanticConcept.vodml»
	«ENDIF»
    «IF e.ucd !== null»
      <UCD>«e.ucd»</UCD>
	«ENDIF»	
	«IF e.key !== null»
	  «e.key.vodml»
	«ENDIF»
	</attribute>
	'''
	
	def vodml (Composition e)
	'''
	<composition>
	  «e.preamble»
	  <datatype>
	     «(e.type as ReferableElement).ref»
	  </datatype>
	  «vodml(e.multiplicity)»
	  «IF e.isOrdered»<isOrdered>true</isOrdered>«ENDIF»
	</composition>
	'''
	

   def ref(ReferableElement e)'''
   <vodml-ref>«converter.toString(e.fullyQualifiedName)»</vodml-ref>
   '''

   def vodml(Reference e)'''
   <reference>
     «e.preamble»
     <datatype>
       «(e.type as ReferableElement).ref»
     </datatype>
     «vodml(e.multiplicity)»
   </reference>
   '''
   
// FIXME this is not really doing correct thing for attributes yet... - but probably needs a VODML schema change to allow multiple constraints....
// TODO should really worry about CDATA end occurring in the exp https://stackoverflow.com/questions/223652/is-there-a-way-to-escape-a-cdata-end-token-in-xml/223782#223782
   def vodml(Constraint e)'''
   <constraint>
      «IF e.expr !== null»
        <description><![CDATA[«e.expr»]]></description>
        <!-- <language>«e.language»</language> -->
      «ENDIF»
   </constraint>
   '''


	def vodml (Enumeration e)'''
	<enumeration>
	   «e.preamble»
      «FOR f: e.literals»
         «f.vodml»
      «ENDFOR»
	</enumeration>
	'''
	def vodml (DataType e)
	'''
	<dataType«IF e.abstract» abstract="true"«ENDIF»>
	  «e.preamble»
	   «IF e.superType !== null»
	   <extends>
	      «(e.superType as ReferableElement).ref»
	   </extends>
	   «ENDIF»
	   «FOR f: e.constraints»
	   	«f.vodml»
	   «ENDFOR»
       «FOR f: e.subsets»
       «f.vodml»
      «ENDFOR»	   
      «FOR f: e.content»
	   	«f.vodml»
	   «ENDFOR» 	
	</dataType>
	'''
	
	def vodml (Multiplicity e)
	{
		if (e !== null)
		{
			if(e.multiplicitySpec !== null)
			{
				switch e.multiplicitySpec {
					case ATLEASTONE: {
						vodml(1,-1)
					}
					case MANY: {
						vodml(0,-1)
					}
					case OPTIONAL: {
						vodml(0,1)
					}
					case ONE:
					{
						if(e.minOccurs != 0)
						{
							vodml(e.minOccurs, e.minOccurs)
						}
						else
						{
							vodml(1,1)
						}
					}
					default:
						vodml(1,1)
					
				}
			}
			else
			{
				vodml(e.minOccurs, e.maxOccurs)
			}
		}
		else
		{
		vodml(1, 1)
		}
	}
	
	def vodml(int minOccurs, int maxOccurs)'''
	<multiplicity>
	  <minOccurs>«minOccurs»</minOccurs>
	  <maxOccurs>«maxOccurs»</maxOccurs>
	</multiplicity>
	'''
	
	
	def vodml (PrimitiveType e)'''
    <primitiveType «IF e.abstract» abstract="true"«ENDIF»>
    «e.preamble»
    «IF e.superType !== null»
 	   <extends>
 	      «(e.superType as ReferableElement).ref»
 	   </extends>
    «ENDIF»	   
    </primitiveType>
	'''
	def vodml (EnumLiteral e)'''
   <literal>
     «e.preamble»
   </literal>	
	'''
	
	def vodml(SubSet e)'''
	<constraint xsi:type="vo-dml:SubsettedRole">
	   <role>
	      «(e.ref as ReferableElement).ref»
	   </role>
	   <datatype>
	      «(e.type as ReferableElement).ref»
	   </datatype>
	</constraint>
	'''
	
	def vodml(NaturalKey e)'''
    <constraint xsi:type="vo-dml:NaturalKey">
    	<position>« if( e.position <1) 1 else e.position»</position>
    </constraint>
	'''
	
	def vodml(SemanticConcept e)'''
	<semanticconcept>
	  «IF e.broadestConcept !== null»
	    <topConcept>«e.broadestConcept»</topConcept>
	  «ENDIF»
	  «IF e.vocabularyURI !== null»
	    <vocabularyURI>«e.vocabularyURI»</vocabularyURI>
	  «ENDIF»
	</semanticconcept>
	'''
}
